# AGENTS.md — Codex CLI 工作准则 v2

面向在 Codex CLI（终端型开源代理）中运行的智能体，提供精炼、可执行、可追溯的团队级工作规则。目标：在安全与合规前提下，最大化效率与质量。

---

## 0. 目的与适用范围

- 适用主体：在本仓库内运行的 Codex CLI 智能体与协作开发者。
- 适用场景：需求分析、方案设计、代码实现、检索调研、测试验证、文档编写与迭代交付。
- 不越权：当本文件与上层系统/开发者指令冲突时，以上层指令为准（见“1. 指令优先级”）。

## 1. 指令优先级与合规

优先级裁决（从高到低）：
1) System（平台/会话系统指令）
2) Developer（开发者消息与环境策略）
3) 子目录 AGENTS.md（就近原则）
4) 本文件（仓库根 AGENTS.md）

合规底线：
- 不输出或写入任何明文密钥/令牌/个人隐私信息（统一以 `****` 遮蔽）。
- 遵守网站 ToS 与 robots；仅做最小必要的网络外呼；标注来源。
- 尊重安全与隐私，不实施恶意或破坏性操作；涉及高风险变更须在答复中明确风险与回滚建议。

冲突处理：
- 若上层指令与本文件存在矛盾，遵循上层；同时在答复中简要说明遵循依据与影响范围。

## 2. 工具矩阵与优先顺序（Codex 原生 + MCP）

按“单轮单工具、最小必要范围、官方优先”的原则选择；以下为校准后的工具清单与定位（结合您提供的资料）：

- 规划与分解：
  - `@modelcontextprotocol/server-sequential-thinking`（复杂/多步骤任务分解与串联推理）。
  - `update_plan`（维护 3–10 步滚动里程碑：默认 3–6，复杂任务可 7–10；任一时刻仅 1 个 `in_progress`）。
  - `mcp-shrimp-task-manager`（可选：计划/反思/拆解模板与任务记忆，用于长任务）。
- 检索与理解代码：
  - 本地优先：`rg`（文本/文件定位）、`code-index-mcp`（代码索引/跨引用/大型仓库导航）。
  - `serena`（本地定制：符号级检索与编辑，find/insert/replace/rename 等）。
- 编辑与变更：
  - `apply_patch`（唯一首选写路径；小步修改，聚焦单一主题）。
- 文档/SDK 官方资料：
  - `@upstash/context7-mcp`（resolve-library-id → get-library-docs；获取官方/特定版本文档，降低过时与幻觉）。
- 最新/跨站信息：
  - `@perplexity-ai/mcp-server`（实时搜索/研究聚合；结果≤35、超时≈5s、必要时一次重试；权威来源优先并标注时间）。
- 受控抓取与精读：
  - `mcp-server-fetch`（将网页转 Markdown；支持并发/代理；仅在需要正文片段时使用）。
- 前端页面洞察：
  - `chrome-devtools-mcp`（基于 Puppeteer 的 DevTools 能力暴露：DOM/网络/性能/自动化交互/追踪）。
- 结构化记忆：
  - `@modelcontextprotocol/server-memory`（跨会话持久记忆/知识图谱；不存密钥/隐私，仅关键约束/偏好/长期事实）。
 - 开源仓库理解：
  - `deepwiki`（GitHub 仓库结构化理解与问答：结构、内容检索、基于仓库上下文的 QA）。
 - 本地桌面/系统协作：
  - `desktop-commander`（终端/进程/文件系统/代码编辑/动态配置的一体化本地控制）。

降级与回退：
- 官方文档（context7）→ 实时聚合（perplexity）→ 抓取精读（fetch）→ 本地保守经验（并标注不确定性）。

### 2.1 MCP 工具卡片（校准版）

- `chrome-devtools-mcp`
  - 用途：以 DevTools 能力驱动浏览器侧实测与诊断（网络、控制台、DOM、性能追踪）。
  - 典型应用：变更后实时验证、自动化点击/填充/拖拽、录制性能追踪并分析。
  - 边界：遵守站点 ToS；避免登录私有账号；不得采集敏感信息。

- `code-index-mcp`
  - 用途：大仓代码索引/搜索/关系分析，提升代码理解与定位效率。
  - 典型应用：跨目录跳转、符号/引用/相似实现定位，辅助重构与大规模变更。

- `@upstash/context7-mcp`
  - 用途：从官方文档源获取最新/指定版本 API 与示例，减少过时与幻觉。
  - 流程：resolve-library-id → get-library-docs（设定 `topic` 与合理 tokens）。

- `mcp-server-fetch`
  - 用途：受控抓取网页正文并转 Markdown；支持并发与代理。
  - 典型应用：研读少量关键页面正文；在 ToS/robots 允许范围内引用要点。

- `@modelcontextprotocol/server-memory`
  - 用途：跨会话持久化记忆（知识图谱化），保持上下文连续与个性化偏好。
  - 注意：不存储密钥/隐私；记录决策、约束、长期事实与偏好。

- `@perplexity-ai/mcp-server`
  - 用途：实时搜索与研究聚合；适合时效性问题与多源对比。
  - 约束：结果≤35、超时≈5s、遇 429 退避并一次重试；提供来源与时间标注。

- `@modelcontextprotocol/server-sequential-thinking`
  - 用途：为复杂任务提供系统化的步骤分解与顺序执行框架。
  - 典型应用：系统设计/长期规划/多模块集成的任务分步实施。

- `serena`（本地定制）
  - 用途：符号级检索与编辑、跨文件引用分析，本地代码操作的“手术刀”。

- `mcp-shrimp-task-manager`
  - 用途：任务规划/拆解/反思与任务记忆；支持研究模式与长期项目跟进。
  - 场景：复杂/长期/研究型任务，与 `update_plan` 互补。

- `deepwiki`
  - 用途：面向 GitHub 开源项目的结构化理解与智能问答。
  - 核心能力：`read_wiki_structure`（仓库主题/目录）、`read_wiki_contents`（指定路径内容）、`ask_question`（基于全仓上下文 QA）。
  - 典型应用：快速上手陌生大仓、学习主流框架、代码评审影响面分析、企业内部知识整合。

- `desktop-commander`
  - 用途：为 Agent 提供本地桌面与系统级协作能力（终端、进程、文件、代码编辑、动态配置）。
  - 典型应用：本地自动化开发流（拉取/构建/测试/打包）、大仓重构与迁移、系统排障与日志分析、低成本离线执行。
  - 边界与合规：建议设置目录白名单与命令黑名单；避免破坏性操作；不写入敏感凭据。

## 3. 标准作业流程（SOP）

四阶段流程覆盖从理解到交付，全程保持“最小必要、可追溯”。

### 阶段 0：扫描与理解（必须）
- 快速定位：
  - 使用 `rg --files` 和 `rg "关键词"` 限定范围，优先找到 1–3 个相似实现或入口文件。
  - 读取文件遵循“每次≤250 行”的输出上限，必要时分段阅读。
- 关键疑问清单（3–5 条，标注高/中/低）：
  - 我已知什么？还有哪些会影响方案或实现？
- 充分性检查（四问）：
  1) 输入/输出是否清晰？
  2) 关键依赖是否就绪？
  3) 主要风险（并发/性能/边界）是否识别？
  4) 验证方式是否明确？
  - 如未满足，先补充最小必要的信息再进入下一阶段。

### 阶段 1：计划与准入（建议）
- 发送 1–2 句 preamble，说明即将执行的动作。
- 使用 `update_plan` 维护 3–10 步滚动里程碑（默认 3–6；复杂任务可 7–10），每步 1 句；始终仅 1 个 `in_progress`。
- 若需要网络/外部工具：
  - 单轮单工具；优先官方（`@upstash/context7-mcp`）与聚合（`@perplexity-ai/mcp-server`）；必要时再抓取（`mcp-server-fetch`）。
  - 为外呼设定：关键词/时间窗/结果上限（≤35）/超时（≈5s）；失败按“降级与回退”。

- 里程碑粒度与上限（建议）：
  - 时间盒：单步预计 15–60 分钟可完成；>90 分钟拆分，<5 分钟合并。
  - 滚动维护：阶段完成即补齐后续 3–5 步，保持可见窗口≤10。
  - 命名规范：每步 5–8 个字描述“可交付动作”，避免含糊动词（如“优化一下”）。
  - 约束：始终仅 1 个 `in_progress`；其余 `pending/ completed` 清晰可审计。
  - 大任务：按“探索→实现→验证→收尾”切片，每阶段各自维护 3–10 步。

### 阶段 2：实施与变更（必须）
- 小步修改：
  - 使用 `apply_patch`；一次补丁只做同一主题的变更；避免大范围联动修改。
  - 对整文件重写或大面积改动，优先“先删后加”的补丁方式，确保易审计。
- 代码规范：
  - 保持项目原有风格（命名/导入顺序/格式化）；
  - 中文注释描述“意图/约束/用法”；
  - 避免过早抽象（至少出现三次重复再提取通用化）；
  - 遵循单一职责与 SOLID 原则；
  - 非必要不做破坏性变更；若必须，提供迁移与回滚建议。
- 检索与阅读：
  - 文本搜索优先 `rg`；大型仓与跨引用优先 `code-index-mcp`/`serena`；
  - 需要页面/前端证据时使用 `chrome-devtools-mcp` 获取 DOM/网络/控制台快照；
  - 需要跨仓/开源项目知识时可用 `deepwiki` 获取仓库结构/内容并进行基于仓库的 QA；
  - 读取输出控制在 250 行内，按块阅读。

### 阶段 3：验证与交付（必须）
- 验证等级（按任务重要度自定）：
  - 轻：关键路径手工/命令快速验证 + 结果说明；
  - 中：为改动核心添加或更新用例/脚本，并给出运行指令；
  - 重：涉及架构/安全/数据一致性的修改需补充边界与异常验证。
- 交付说明包含：
  - 变更概述（做了什么、为什么）；
  - 使用/运行/验证步骤（命令与期望输出要点）；
  - 已知风险与后续建议；
  - `update_plan` 标记完成。

## 4. 代码与补丁约定

- `apply_patch` 是唯一首选写路径：
  - 小步聚焦：每次补丁只解决一个问题或交付一个最小特性；
  - 大改策略：对整段不可稳定定位的内容，优先“Delete + Add”确保补丁可干净应用；
  - 不跨域混杂：避免在同一补丁内引入无关联重构。
- 源码阅读：
  - 使用 `rg` 与分段 `sed -n 'start,endp'` 控制输出体量；
  - 符号检索与交叉引用优先 `code-index`/`serena` 系列工具。
- 文件与命名：
  - 保持与现有目录/命名约定一致；新增文件放在最合适的既有分层下。
- 注释与文档：
  - 注释使用中文，描述“目的/约束/边界/用法”，避免复述代码字面；
  - 若引入第三方接口，注明主要版本与关键参数。

## 5. 外部信息与网络访问

- 官方优先：
  - SDK/框架：`@upstash/context7-mcp`（resolve-library-id → get-library-docs；topic 聚焦；合理 tokens）。
  - 最新/跨站对比：`@perplexity-ai/mcp-server`（结果≤35、超时≈5s、一次重试，来源与时间标注）。
- 受控抓取：
  - `mcp-server-fetch` 仅在需要正文片段时使用；遵守 ToS/robots；避免登录/付费墙后内容。
- 可追溯与最小必要：
  - 提供来源链接与抓取时间（在答复或代码注释中简述）；
  - 仅保留关键事实与要点，避免大段复制。
- 敏感信息：
  - 绝不输出明文密钥/Token；如需说明，统一遮蔽为 `****`；`server-memory` 不存敏感信息。

## 10. 参考资料（摘录）

以下资料用于校准 MCP 工具的用途与边界（示例选摘，更多请参考各官方文档）：
- chrome-devtools-mcp：Chrome DevTools MCP 介绍与实践 [1][2][3][4]
- code-index-mcp：代码索引 MCP 用途与案例 [5][6]
- @upstash/context7-mcp：从官方文档源获取最新/指定版本资料 [7][8]
- mcp-server-fetch：网页转 Markdown、并发与代理能力 [9][10]
- @modelcontextprotocol/server-memory：持久化记忆与知识图谱 [11][12]
- @perplexity-ai/mcp-server：实时搜索与研究聚合 [13][14]
- @modelcontextprotocol/server-sequential-thinking：复杂任务分解与顺序执行 [15][16]
- mcp-shrimp-task-manager：任务规划与研究模式 [17][18][19][20]
 - deepwiki：GitHub 仓库结构/内容检索与智能问答 [1][3][5][6][7][8]
 - desktop-commander：本地桌面/系统协作（终端/文件/编辑/配置） [1][2][3][4][6][7][14]

## 6. 度量与守护（建议）

- 流程度量：
  - preamble 覆盖率；`update_plan` 同步率（步骤状态准确）；
  - 补丁粒度（单补丁触及文件/行数分布）；
  - 外呼最小性（调用频率、结果上限与时间窗）；
  - 验证完备度（按任务等级的验证覆盖）。
- 回退与重试：
  - 连续 3 次同类失败须暂停，复盘并调整策略后再继续。

## 7. 常见场景速查

- 新功能（小特性）：
  1) 阶段 0：定位模块与相似实现 → 列关键疑问；
  2) 阶段 1：`update_plan` 建 3–8 步；
  3) 阶段 2：`apply_patch` 小步交付；
  4) 阶段 3：给出运行/验证步骤与结果要点。

- Bug 修复：
  1) 复现与最小化输入；
  2) `rg`/`code-index-mcp` 定位根因；
  3) 小步修复并添加回归验证；
  4) 在交付说明中写明原因与回归点。

- 依赖升级：
  1) 官方变更点梳理（`@upstash/context7-mcp`）；
  2) 兼容性与破坏性评估；
  3) 分步升级、可回滚；
  4) 核心路径验证与运行指令。

- 文档更新：
  1) 明确受众与目标；
  2) 用最小可读结构（标题 + 要点 + 命令/路径示例）；
  3) 提供可执行的验证或用法片段。

## 8. 语言与输出风格（对 Codex CLI 友好）

- 全中文表达，包括注释与文档。
- 简洁直接：以短句和要点为主，避免冗长叙述。
- 结构化输出：
  - 使用简短小节标题与 4–6 条要点；
  - 仅在有助阅读时使用小节标题；
  - 命令、文件、环境变量与标识符使用反引号包裹。
- 文件引用：使用路径与行号（示例：`src/app.ts:42`、`b/server/index.js#L10`）。

## 9. 示例片段（文档内示例，仅供参考，不强制生成额外文件）

示例 1：preamble（在执行前简述）

> “我将扫描相关目录，随后补丁实现参数校验，并附带最小验证步骤。”

示例 2：`update_plan` 里程碑（仅示意）

```
1. 定位模块与相似实现（in_progress）
2. 设计与接口准入（pending）
3. 实现与补丁提交（pending）
4. 验证与交付说明（pending）
```

示例 3：`apply_patch` 小步补丁（仅示意）

```
*** Begin Patch
*** Update File: internal/validator/params.go
@@
- // TODO: implement later
+ // 校验输入参数：非空、范围、格式
+ func Validate(p *Params) error {
+     // ... 省略细节：保持单一职责与最小可验证
+ }
*** End Patch
```

示例 4：网络外呼的“最小必要”说明（答复中简述）

```
- 工具：context7（官方文档）
- 目标：确认 vX.Y API 参数变化
- 范围：topic=auth；tokens=3000；超时≈5s
- 结果：发现废弃字段 A、新增 B（链接：...）
```

---

以本 v2 为团队协作的最小可执行准则：
- 做到“先理解、再计划、后变更、终验证”；
- 保持补丁小而准，验证简洁可复现；
- 优先官方来源与本地检索，外呼最小必要，可追溯；
- 在安全与合规前提下，极致发挥 Codex 能力。
